#!/usr/bin/env node
/** ------------------------------------------------------------------------------------------------
 *  @filename  pre-commit-lint.js
 *  @author  brikcss  <https://github.com/brikcss>
 *  @description  Git pre-commit hook which runs eslint, stylelint, and prettier on **staged
 *    files**. This minimizes the need to run these tools during build.
 *
 *  @param  {list}  [ignore]  Comma-separated list of file types to ignore (js, json, or css).
 *  @param  {list}  [js] (.js)  Comma-separated list of file extensions to run through eslint and
 *      prettier as JS files.
 *  @param  {list}  [json] (.json)  Comma-separated list of file extensions to run through prettier
 *      as JSON files.
 *  @param  {list}  [css] (.css)  Comma-separated list of file extensions to run through stylelint
 *      and prettier as CSS (or SASS/LESS/etc.) files.
 ** --------------------------------------------------------------------------------------------- */
/* eslint-env node, es6 */

// -------------------
// Set up environment.
//

const options = require('minimist')(process.argv.slice(1));
const log = require('loglevel');
const shell = require('shelljs');
const fs = require('fs-extra');
const path = require('path');
const promises = [];
const fileExts = {};
const statusCodesToIgnore = [' ', 'D', '?'];
let files = {
	js: [],
	json: [],
	css: [],
	staged: [],
	partiallyUnstaged: []
};

// Set default flags / options.
log.setLevel(options.loglevel || 'info');
options.ignore = options.ignore ? options.ignore.split(',') : [];
if (options.ignore.indexOf('js') === -1) fileExts.js = options.js ? options.js.split(',') : ['.js'];
if (options.ignore.indexOf('json') === -1)
	fileExts.json = options.json ? options.json.split(',') : ['.json'];
if (options.ignore.indexOf('css') === -1)
	fileExts.css = options.css ? options.css.split(',') : ['.css'];

// ----------------------
// Get the party started.
//
log.info('\n [i] Running precommit linters...\n');

// --------------------------------------------
// Get filepaths for staged JS/JSON/SASS files.
//

// Status codes (https://git-scm.com/docs/git-status):
//   ' ' = File changed since added to index.
//   'D' = File deleted.
//   '?' = Untracked file.
// Loop through all modified styles and cache to various file types we're interested in.
shell
	.exec('git status --porcelain', { silent: true })
	.stdout.split('\n')
	.forEach(function(file) {
		file = {
			status: file.slice(0, 2),
			path: file.slice(3)
		};
		// If file was Renamed ('R'), grab the renamed path. Renamed filepaths are stored like this:
		// RM example.txt -> build/example.txt
		if (file.status[0] === 'R') {
			file.path = file.path.slice(file.path.indexOf('-> ') + 3);
		}

		// Use cases to skip:
		//   - package.json (frequently modified by npm)
		//   - package-lock.json (auto-generated by npm)
		//   - file paths that include `statusCodesToIgnore`
		if (
			path.basename(file.path) === 'package-lock.json' ||
			path.basename(file.path) === 'package.json' ||
			statusCodesToIgnore.indexOf(file.status[0]) > -1
		) {
			return true;
		}

		// Cache all staged filepaths.
		files.staged.push(file.path);

		// Cache staged files that have the extensions we're in.
		Object.keys(fileExts).some(function(key) {
			if (fileExts[key].indexOf(path.extname(file.path)) > -1) {
				log.info(`     ${file.status} ${file.path} (${key})`);
				files[key].push(file.path);

				// Cache partially unstaged files. NOTE: Partially unstaged files have both staged
				// and unstaged portions. The reason we need to stash these is because the linters
				// may modify and add files. If there are partially unstaged files, the unstaged
				// portions would get added, undesirably so.
				if (file.status[1] !== ' ') {
					// Get content if the file is modified.
					if (file.status[1] === 'M') {
						file.content = fs.readFileSync(file.path);
					}
					// Cache the file.
					files.partiallyUnstaged.push(file);
					// Remove unstaged changes.
					shell.exec(`git checkout -- ${file.path}`);
				}
				return true;
			}
		});
	});
log.debug(files);

// -----------------------------------------
// Exit if no JS/JSON/SASS files are staged.
//
if (!files.js.length && !files.css.length && !files.json.length) {
	const fileTypes = Object.keys(fileExts);
	log.warn(
		`\n [ok] No staged ${fileTypes.length ? fileTypes.join('/') + ' ' : ''}files to lint.`
	);
	process.exit(0);
}

// ----------------------------
// Process each group of files.
//

// Process SASS files: prettier > stylelint > git add.
if (files.css.length) {
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.css.join(
				' '
			)} --write --loglevel=error --color=always && node ./node_modules/.bin/stylelint ${files.css.join(
				' '
			)} --color always`
		)
	);
}

// Process JS files: prettier > eslint > git add.
if (files.js.length) {
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.js.join(
				' '
			)} --write --loglevel=error --color=always && node ./node_modules/.bin/eslint ${files.js.join(
				' '
			)} --color always --fix`
		)
	);
}

// Process JSON files: prettier > git add.
if (files.json.length) {
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.json.join(
				' '
			)} --write --loglevel=error --color=always`
		)
	);
}

// ----------------------------------------------------
// Process results after all file groups are processed.
//
try {
	Promise.all(promises)
		.then((results) => {
			let errors = [];
			// Check for errors.
			results.forEach(function(result) {
				if (!result.success) {
					errors.push(result.error);
				}
			});
			// Throw any errors now.
			if (errors.length) {
				throwError(errors);
			} else {
				// If there are no errors, add newly formatted/linted files to the commit, then reset stage.
				shell.exec(`git add ${files.staged.join(' ')}`);
				resetStage();
			}
			// Notify user.
			log.warn('\n[ok] Done! Committing changes...');
			return;
		})
		.catch((errors) => throwError(errors, 'Uh oh... there was a problem...'));
} catch (error) {
	log.error('\n[!!] Uh oh... there was a problem...\n', error);
	process.exit(1);
}

// ----------
// Functions.
//

/**
 *  Create a promise to run an asyncronous command via shell.exec().
 *
 *  @param   {string}  stringCommand  Command to run via shell.exec().
 *  @return  {promise}  Promise to return command result.
 */
function createPromise(stringCommand) {
	return new Promise(function(resolve) {
		shell.exec(stringCommand, { async: true, silent: true }, function(code, stdout, stderr) {
			if (code > 0) {
				let error = {
					code,
					message: stderr || stdout
				};
				if (error.message) {
					error.message = '     ' + error.message.replace(/\n/g, '\n     ');
				}
				resolve({
					success: false,
					error
				});
			} else if (stdout.trim().length) {
				log.warn('     ' + stdout.trim().replace(/\n/g, '\n     '));
			}
			resolve({ success: true });
		});
	});
}

/**
 *  Throw an error and exit without committing.
 *
 *  @param   {array|object|string}  errors  Error to throw.
 *  @param   {string}  introMsg  Message to show at beginning.
 *  @return  {boolean}  Always returns false.
 */
function throwError(
	errors,
	introMsg = 'Uh oh... there are errors you need to fix before you can commit these changes...'
) {
	// Log intro message.
	log.error(`\n[!!] ${introMsg}\n`);
	// Log each error.
	if (errors instanceof Array) {
		errors.forEach(function(error) {
			if (error.message) {
				log.error(error.message);
			}
		});
	} else {
		log.error(errors);
	}
	// Reset the git state.
	resetStage();
	// Exit with error code 1.
	process.exit(1);
	return false;
}

/**
 *  Reset git's stage and reapply files that were previously partially unstaged.
 */
function resetStage() {
	const filesToReset = files.staged.join(' ');
	// Reset the stage.
	shell.exec(`git checkout -- ${filesToReset}`);
	// Restore cached partially unstaged files to their original form.
	if (files.partiallyUnstaged.length) {
		log.info('\n\n [i] Reapplying partially unstaged changes...');
		files.partiallyUnstaged.forEach((file) => {
			// Restore modified and deleted files.
			if (file.status[1] === 'M') {
				log.info(`     Restoring ${file.path}...`);
				fs.writeFileSync(file.path, file.content);
			} else if (file.status[1] === 'D') {
				log.info(`     Removing ${file.path}...`);
				fs.unlinkSync(file.path);
			}
		});
		log.info('     Done.\n');
	}
}
